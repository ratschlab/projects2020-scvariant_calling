#include "pileup.hpp"
#include "util/pileup_reader.hpp"

#include <gmock/gmock.h>
#include <gtest/gtest.h>

namespace {

using namespace ::testing;

/**
 * Tests that reading BAM files where too few positions differ from the majority returns an empty
 * result.
 */
TEST(pileup, read_too_few_differnt) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    std::vector<PosData> data = pileup_bams({ "data/test1.bam", "data/test1.bam", "data/test1.bam",
                                              "data/test2.bam", "data/test2.bam" },
                                            "data/test_pileup", true, chromosome_id, max_coverage,
                                            1, min_map_quality, min_alignment_score, 1, 3);
    ASSERT_EQ(0, data.size());

    auto [data2, cell_ids, max_len] = read_pileup("data/test_pileup.bin", { 0, 1 });
    ASSERT_EQ(0, data2.size());

    data = pileup_bams({ "data/test1.bam", "data/test1.bam", "data/test1.bam", "data/test2.bam",
                         "data/test2.bam" },
                       "data/test_pileup", true, chromosome_id, max_coverage, 1, min_map_quality,
                       min_alignment_score, 1, 1);
    // only the first position is identical in both files, we we get 9 out of 10 positions
    ASSERT_EQ(9, data.size());
}

/**
 * Checks that the content of #data matches what's in test1.sam and test2.sam
 */
void check_content(const std::vector<PosData> &data) {
    ASSERT_EQ(9, data.size());
    for (uint32_t i = 0; i < 4; ++i) {
        ASSERT_EQ(2, data[i].size());
        ASSERT_EQ(0, data[i].read_ids[0]);
        ASSERT_EQ(1, data[i].read_ids[1]);
        ASSERT_EQ(0, data[i].base(0));
        ASSERT_EQ(2, data[i].base(1));
        ASSERT_EQ(0, data[i].cell_id(0));
        ASSERT_EQ(1, data[i].cell_id(1));
    }
    for (uint32_t i = 4; i < 9; ++i) {
        ASSERT_EQ(2, data[i].size());
        ASSERT_EQ(0, data[i].read_ids[0]);
        ASSERT_EQ(1, data[i].read_ids[1]);
        ASSERT_EQ(1, data[i].base(0));
        ASSERT_EQ(3, data[i].base(1));
        ASSERT_EQ(0, data[i].cell_id(0));
        ASSERT_EQ(1, data[i].cell_id(1));
    }
}

/**
 * Tests that the data returned by #pileup_bams matches what's in test1.bam and test2.bam
 */
TEST(pileup, read) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    std::vector<PosData> data = pileup_bams({ "data/test1.bam", "data/test2.bam" },
                                            "data/test_pileup_1", true, chromosome_id, max_coverage,
                                            1, min_map_quality, min_alignment_score, 1, 1);
    check_content(data);
    std::filesystem::remove_all("data/test_pileup_1*");
}

/**
 * Tests that the pileup file generated by #pileup_bams matches what's in test1.bam and test2.bam
 */
TEST(pileup, read_file) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    pileup_bams({ "data/test1.bam", "data/test2.bam" }, "data/test_pileup_2", true, chromosome_id,
                max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    auto [data, cell_count, max_len] = read_pileup("data/test_pileup_2.bin", { 0, 1 });
    // first pos is 2 because pos 1 is eliminated, last post is 425 -> 425-2 = 423
    ASSERT_EQ(423, max_len);
    ASSERT_EQ(cell_count, 2);
    check_content(data);
    std::filesystem::remove_all("data/test_pileup_2*");
}

/**
 * Tests that soft clippings are correctly handled by the pileup reader.
 */
TEST(pileup, soft_clipping) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    pileup_bams({ "data/soft_clipping.bam", "data/test2.bam" }, "data/test_pileup_3", true,
                chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    auto [data, cell_count, max_len] = read_pileup("data/test_pileup_3.bin", { 0, 1 });
    // first pos is 2 because pos 1 is eliminated, last post is 425 -> 425-2 = 423
    ASSERT_EQ(423, max_len);
    ASSERT_EQ(cell_count, 2);
    check_content(data);
    std::filesystem::remove_all("data/test_pileup_3*");
}

/**
 * Tests that hard clippings are correctly handled by the pileup reader.
 */
TEST(pileup, hard_clipping) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    pileup_bams({ "data/hard_clipping.bam", "data/test2.bam" }, "data/test_pileup_4", true,
                chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    auto [data, cell_count, max_len] = read_pileup("data/test_pileup_4.bin", { 0, 1 });
    // first pos is 2 because pos 1 is eliminated, last post is 425 -> 425-2 = 423
    ASSERT_EQ(423, max_len);
    ASSERT_EQ(cell_count, 2);
    check_content(data);
    std::filesystem::remove_all("data/test_pileup_4*");
}

/**
 * On rare occasions, the cigar string ends with an I (no idea why). Make sure such cases are
 * correctly handled.
 */
TEST(pileup, insert_at_end) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 0;
    pileup_bams({ "data/insert_at_end.bam", "data/test2.bam" }, "data/test_pileup_5", true,
                chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    auto [data, cell_count, max_len] = read_pileup("data/test_pileup_4.bin", { 0, 1 });
    // first pos is 2 because pos 1 is eliminated, last post is 425 -> 425-2 = 423
    ASSERT_EQ(423, max_len);
    ASSERT_EQ(cell_count, 2);
    check_content(data);
    std::filesystem::remove_all("data/test_pileup_4*");
}

/**
 * Tests that filtering BAM files by mapping quality works as expected
 */
TEST(pileup, test_mapping_quality) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 7;
    uint32_t min_alignment_score = 0;
    std::vector<PosData> data = pileup_bams({ "data/test1.bam", "data/test2.bam" },
                                            "data/test_pileup", true, chromosome_id, max_coverage,
                                            1, min_map_quality, min_alignment_score, 1, 1);
    ASSERT_TRUE(data.empty());

    min_map_quality = 6; // the mapping quality is exactly 6, so this should return all the records
    data = pileup_bams({ "data/test1.bam", "data/test2.bam" }, "data/test_pileup", true,
                       chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    ASSERT_EQ(9, data.size());
}

/**
 * Tests that filtering BAM files by alignment score works as expected
 */
TEST(pileup, test_alignment_score) {
    uint32_t chromosome_id = 0;
    uint32_t max_coverage = 10;
    uint32_t min_map_quality = 0;
    uint32_t min_alignment_score = 10;
    std::vector<PosData> data = pileup_bams({ "data/test3.bam", "data/test3.bam" },
                                            "data/test_pileup", true, chromosome_id, max_coverage,
                                            1, min_map_quality, min_alignment_score, 1, 0);
    ASSERT_EQ(168, data.size()); // 168 = 2 reads, 84 bases each

    min_alignment_score = 85; // this should eliminate both reads (scores are 79 and 84)
    data = pileup_bams({ "data/test3.bam", "data/test3.bam" }, "data/test_pileup", true,
                       chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 1);
    ASSERT_TRUE(data.empty());

    min_alignment_score = 80; // this should eliminate one read (scores are 79 and 84)
    data = pileup_bams({ "data/test3.bam", "data/test3.bam" }, "data/test_pileup", true,
                       chromosome_id, max_coverage, 1, min_map_quality, min_alignment_score, 1, 0);
    ASSERT_EQ(84,data.size());
}

} // namespace
