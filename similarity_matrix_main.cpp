/*
 * Generate the distance/affinity matrix that approximates the probability that two cells i and j
 * have the same genotype. The input is a pre-processed mpileup, which contains all of the sequenced
 * bases (piled up) for each position as generated by preprocessing.py.
 * Each line in the file has the form:
 * chromosome_id    position    coverage    bases   cells   read_ids
 * For example the line:
 * 22      10719571        2       TAG      0,0,3  read_id1,read_id2,read_id3
 * Means that at position 10719571 of chromosome 22, we read 'T' and 'A' in cell 0 and 'G' in cell 3
 */

#include "util.hpp"

#include <gflags/gflags.h>
#include <omp.h>
#include <progress_bar/progress_bar.hpp>

#include <deque>
#include <filesystem>
#include <fstream>
#include <limits>
#include <numeric>
#include <sstream>
#include <unordered_map>
#include <vector>

#include <cassert>
#include <cmath>

DEFINE_double(seq_error_rate, 0.001, "Sequencing errors rate, denoted by theta");
DEFINE_double(mutation_rate,
              0,
              "epsilon, estimated frequency of mutated loci in the pre-processed data set");
// estimate of how many positions are actually homozygous germline, were only included because of
// sequencing (or alignment!) errors
DEFINE_double(
        hzygous_prob,
        0,
        "The probability that a loci is homozygous, (not filtered correctly in the first step");

DEFINE_string(mpileup_file,
              "",
              "Input file containing 'pileup' textual format from an alignment, as written by "
              "preprocessing.py");
DEFINE_uint32(num_cells, 0, "Number of sequenced cells");
DEFINE_string(cells_file,
              "",
              "File with identifiers of cells (numbers between 0 and (num_of_cells - 1); the "
              "matrices will be computed only for these cells; if absent, all cells are used.");
DEFINE_string(cell_group_file,
              "",
              "For each cell, it contains a group to which it belongs. Cells from one group will "
              "be treated as one cell. Useful e.g. when creating data with artificially higher "
              "coverage; if absent, each cell has its own group");

DEFINE_string(out_dir, "./", "Directory where the similarity matrices will be written to");
DEFINE_uint32(run_id,
              0,
              "Identifier of the run (e.g. chromosome number); the resulting files will be called "
              "'mat_same_<run_id>.csv' and 'mat_diff_<id>.csv'");
DEFINE_uint32(max_read_size,
              1000,
              "Maximal considered insert size (for paired-end sequencing). In plain English, this "
              "is the maximal length of a read we consider. Reads that are longer will not be "
              "mapped correctly.");

DEFINE_uint32(num_threads, 8, "Number of threads to use");


/** Caches a bunch of combinations and powers used again and again in the computation */
struct Cache {
    const double epsilon = FLAGS_mutation_rate;
    const double h = FLAGS_hzygous_prob;

    // probability that two same letters will be read as different
    const double theta = FLAGS_seq_error_rate;
    const double theta2 = theta * theta;
    const double p_same_diff = 2 * theta * (1 - theta) + 2 * theta2 / 3;
    // probability that two same letters will be read as same
    const double p_same_same = 1 - p_same_diff;
    // probability that two different letters will be read as same
    const double p_diff_same = 2 * (1 - theta) * theta / 3 + 2 * theta2 / 9;
    // probability that two different letters will be read as different
    const double p_diff_diff = 1 - p_diff_same;

    std::vector<double> pow_p_same_same = { 1, p_same_same };
    std::vector<double> pow_p_same_diff = { 1, p_same_diff };
    std::vector<double> pow_p_diff_same = { 1, p_diff_same };
    std::vector<double> pow_p_diff_diff = { 1, p_diff_diff };

    std::vector<double> pow_1_h_epsilon = { 1, 1 - epsilon - h };
    std::vector<double> pow_1_h_epsilon2 = { 1, 1 - epsilon * 0.5 - h };
    std::vector<double> pow_h_epsilon2 = { 1, h + epsilon * 0.5 };
    std::vector<double> pow_h = { 1, h };
    std::vector<double> pow_epsilon = { 1, epsilon };
    std::vector<double> pow_0_5 = { 1, 0.5 };
    std::vector<double> pow_pss_pds = { 1, p_same_same + p_diff_same };
    std::vector<double> pow_psd_pdd = { 1, p_same_diff + p_diff_diff };

    Mat64u comb = { { 1 }, { 1, 1 } };


    Cache() {
        std::cout << "Pre-computing combinations and powers...";
        auto extend = [](std::vector<double> &a) { a.push_back(a.back() * a[1]); };
        for (uint32_t p = 2; p < FLAGS_max_read_size; ++p) {
            extend(pow_p_same_same);
            extend(pow_p_same_diff);
            extend(pow_p_diff_same);
            extend(pow_p_diff_diff);
            extend(pow_1_h_epsilon);
            extend(pow_1_h_epsilon2);
            extend(pow_h_epsilon2);
            extend(pow_h);
            extend(pow_epsilon);
            extend(pow_0_5);
            extend(pow_pss_pds);
            extend(pow_psd_pdd);
            std::vector<uint64_t> new_comb(p + 1);
            new_comb[0] = 1;
            new_comb.back() = 1;
            for (uint32_t i = 1; i < comb.back().size(); ++i) {
                new_comb[i] = comb.back()[i - 1] + comb.back()[i];
            }
            comb.push_back(std::move(new_comb));
        }
        std::cout << "done" << std::endl;
    }
};

/**
 * Retrieve or compute the probability of having (x_s, x_d) matches/mismatches assuming cells have
 * different genotypes.
 * @param x_s the number of matches
 * @param x_d the number of mismatches
 * @param c caches frequently computed values, such as combinations and powers of h and
 * epsilon
 * @param[in, out] log_probs table containing the cached log probabilities of cells being
 * *different* for x_s and x_d; if the table is empty at the desired location, the value is computed
 * @param[in, out] combs_xs_xd number of times we have seen a combination of x_s and x_d
 */
double log_prob_diff_genotype(uint32_t x_s,
                              uint32_t x_d,
                              const Cache &c,
                              Matd &log_probs,
                              Mat32u &combs_xs_xd) {
    combs_xs_xd[x_s][x_d]++;
    if (log_probs[x_s][x_d] != std::numeric_limits<double>::max()) {
        return log_probs[x_s][x_d];
    }
    double prob = 0;
    for (uint32_t k = 0; k <= x_s; ++k) {
        for (uint32_t l = 0; l <= x_d; l++) {
            for (uint32_t p = 0; p <= x_s - k; ++p) {
                for (uint32_t q = 0; q <= x_d - l; ++q) {
                    prob += c.comb[x_s][k] * c.comb[x_d][l] * c.comb[x_s - k][p]
                            * c.comb[x_d - l][q] * c.pow_1_h_epsilon[k + l] * 0.5
                            * (c.pow_p_same_same[k] * c.pow_p_same_diff[l]
                               + c.pow_p_diff_same[k] * c.pow_p_diff_diff[l])
                            * c.pow_epsilon[x_s + x_d - k - l - p - q]
                            * c.pow_0_5[x_s + x_d - k - l - p - q] * c.pow_pss_pds[x_s - k - p]
                            * c.pow_psd_pdd[x_d - l - q] * c.pow_h[p + q] * c.pow_p_same_same[p]
                            * c.pow_p_same_diff[q];
                }
            }
        }
    }
    prob *= c.comb[x_s + x_d][x_s];
    log_probs[x_s][x_d] = log(prob);
    return log_probs[x_s][x_d];
}

/**
 * Retrieve or compute the probability of having (x_s, x_d) matches/mismatches assuming cells have
 * the same genotype.
 * @param x_s the number of matches
 * @param x_d the number of mismatches
 * @param c caches frequently computed values, such as combinations and powers of h and
 * epsilon
 * @param[in, out] log_probs table containing the cached log probabilities of cells having the samge
 * genotype given x_s and x_d; if the table is empty at the desired location, the value is computed
 * @param[in, out] combs_xs_xd number of times we have seen a combination of x_s and x_d
 */
double log_prob_same_genotype(uint32_t x_s,
                              uint32_t x_d,
                              const Cache &c,
                              Matd &log_probs,
                              Mat32u &combs_xs_xd) {
    combs_xs_xd[x_s][x_d]++;
    if (log_probs[x_s][x_d] != std::numeric_limits<double>::max()) {
        return log_probs[x_s][x_d];
    }
    double p = 0;
    for (uint32_t k = 0; k <= x_s; ++k) {
        for (uint32_t l = 0; l <= x_d; l++) {
            p += c.comb[x_s][k] * c.comb[x_d][l] * c.pow_1_h_epsilon2[k + l] * 0.5
                    * (c.pow_p_same_same[k] * c.pow_p_same_diff[l]
                       + c.pow_p_diff_same[k] * c.pow_p_diff_diff[l])
                    * c.pow_h_epsilon2[x_s + x_d - k - l] * c.pow_p_same_same[x_s - k]
                    * c.pow_p_same_diff[x_d - l];
        }
    }
    p *= c.comb[x_s + x_d][x_s];
    log_probs[x_s][x_d] = log(p);
    return log_probs[x_s][x_d];
}

struct Read {
    std::vector<char> bases; // the DNA sequence corresponding to this read
    uint32_t line;
    uint32_t cell_id;
    std::vector<uint64_t> pos;
};

struct ParsedLine {
    uint32_t pos; // 1-based position on the chromosome
    std::string bases; // the bases read, one for each coverage
    std::vector<uint32_t> cell_ids; // the cell that produced each read, one for each coverage
    std::vector<std::string> read_ids; // long string identifying each read
};

// parses a line from the preprocessed file and returns the corresponding read
ParsedLine parse_line(const std::string &line) {
    assert(!line.empty());
    std::stringstream stream(line);
    uint32_t unused, position;
    stream >> unused >> position >> unused;
    std::string bases, cell_ids, read_ids;
    stream.get(); // ignore next tab
    std::getline(stream, bases, '\t');
    std::getline(stream, cell_ids, '\t');
    std::getline(stream, read_ids, '\t');
    return { position, bases, int_split(cell_ids, ','), split(read_ids, ',') };
}

/**
 * Compares the read #start_idx with all the subsequent reads (as determined by #active_keys) and
 * updates mat_same and mat_diff accordingly. Well it doesn't update mat_same and mat_diff directly
 * in order to avoid a critical section, it pushes the updates into #updates_same and #updates_diff.
 */
void compare_with_reads(const std::unordered_map<std::string, Read> &active_reads,
                        const std::deque<std::string> &active_keys,
                        uint32_t start_idx,
                        const std::vector<uint32_t> &cell_ids,
                        const std::vector<uint32_t> &cell_groups,
                        const Cache &cache,
                        Mat<std::tuple<uint32_t, uint32_t, double>> &updates_same,
                        Mat<std::tuple<uint32_t, uint32_t, double>> &updates_diff,
                        Matd &log_probs_same,
                        Matd &log_probs_diff,
                        Mat32u &combs_xs_xd) {
    const Read &read1 = active_reads.at(active_keys.at(start_idx));
    for (uint32_t idx = start_idx + 1; idx < active_keys.size(); ++idx) {
        const Read &read2 = active_reads.at(active_keys[idx]);
        uint32_t index1 = cell_groups[cell_ids[read1.cell_id]];
        uint32_t index2 = cell_groups[cell_ids[read2.cell_id]];
        if (index1 == index2 || read2.pos.front() > read1.pos.back()) {
            continue; // read intersection is void, or reads are from the same cell
        }

        //  read is not from the same cell -> count the number of matches and mismatches in the
        //  overlap (all active reads include the current position in the genome, so they overlap)
        uint32_t x_s = 0;
        uint32_t x_d = 0;
        for (uint32_t idx1 = 0, idx2 = 0; idx1 < read1.bases.size() && idx2 < read2.bases.size();) {
            if (read1.pos[idx1] == read2.pos[idx2]) {
                toupper(read1.bases[idx1++]) == toupper(read2.bases[idx2++]) ? x_s++ : x_d++;
            } else {
                read1.pos[idx1] < read2.pos[idx2] ? idx1++ : idx2++;
            }
        }

        if (x_s == 0 && x_d == 0) {
            continue; // no overlapping positions, nothing to do
        }

        // update the distance matrices
        updates_same[omp_get_thread_num()].push_back(std::make_tuple(
                index1, index2,
                log_prob_same_genotype(x_s, x_d, cache, log_probs_same, combs_xs_xd)));
        updates_diff[omp_get_thread_num()].push_back(std::make_tuple(
                index1, index2,
                log_prob_diff_genotype(x_s, x_d, cache, log_probs_diff, combs_xs_xd)));
    }
}

/** Applies the updates in the updates vector to mat */
void apply_updates(Mat<std::tuple<uint32_t, uint32_t, double>> &updates, Matd &mat) {
    for (auto &update : updates) {
        for (auto [i, j, v] : update) {
            mat[i][j] += v;
            mat[j][i] = mat[i][j];
        }
        update.resize(0);
    }
}

/**
 * Compute mat_same (the matrix giving probabilities of cells i and j given they are in
 * the same cluster) and mat_diff (prob. of cells i and j given they are in different clusters)
 */
void computeSimilarityMatrix(const std::vector<uint32_t> &cell_ids,
                             const std::vector<uint32_t> &cell_groups) {
    constexpr uint32_t read_len = 100; // maximum read length for computing the

    // distance matrices - the desired result of the computation
    Matd mat_same = newMat(FLAGS_num_cells, FLAGS_num_cells, 0.);
    Matd mat_diff = newMat(FLAGS_num_cells, FLAGS_num_cells, 0.);

    // stores temp updates to mat_same and mat_diff in order to avoid a critical section
    Mat<std::tuple<uint32_t, uint32_t, double>> updates_same(FLAGS_num_threads);
    Mat<std::tuple<uint32_t, uint32_t, double>> updates_diff(FLAGS_num_threads);

    // arrays with values of already computed probabilities, max_double if not yet computed
    Matd log_probs_same = newMat(read_len, read_len, std::numeric_limits<double>::max());
    Matd log_probs_diff = newMat(read_len, read_len, std::numeric_limits<double>::max());

    // count how many times we have seen a given combination of x_s, x_d
    Mat32u combs_xs_xd = newMat(read_len, read_len, 0u);

    // key: read id of an active read
    // value: A Read struct, containing: sequence, line number, cell_id and position in genome
    std::unordered_map<std::string, Read> active_reads;

    Cache cache; // store intermediate values to avoid recomputation

    // traverse the pre-processed mpileup file line by line. Each line in the file has the form:
    // chromosome_id    position    coverage    bases   cells   read_ids
    std::ifstream f(FLAGS_mpileup_file);
    std::string line;
    ProgressBar read_progress(std::filesystem::file_size(FLAGS_mpileup_file), "Processed;",
                              std::cout);
    std::deque<std::string> active_keys;
    // the number of completed reads, i.e. reads that started FLAGS_max_read_size ago
    uint32_t completed = 0;
    for (uint32_t line_count = 0; std::getline(f, line); ++line_count) {
        // splits the line by tabs and fills in the relevant fields into parsed_line
        ParsedLine curr_read = parse_line(line);

        // update the number of complete reads
        for (uint32_t i = completed; i < active_keys.size()
             && active_reads[active_keys[i]].pos[0] + FLAGS_max_read_size <= curr_read.pos;
             ++i) {
            ++completed;
        }

        constexpr uint32_t BATCH_SIZE = 4;
        // if we batched up enough completed reads, process them in parallel
        if (completed >= BATCH_SIZE * FLAGS_num_threads) {
#pragma omp parallel for schedule(static, BATCH_SIZE) num_threads(FLAGS_num_threads)
            for (uint32_t i = 0; i < completed; ++i) {
                // compute its overlaps with all other active reads, i.e. all
                // reads that have some bases in the last FLAGS_max_read_size positions
                compare_with_reads(active_reads, active_keys, i, cell_ids, cell_groups, cache,
                                   updates_same, updates_diff, log_probs_same, log_probs_diff,
                                   combs_xs_xd);
            }
            apply_updates(updates_same, mat_same);
            apply_updates(updates_diff, mat_diff);
            // remove processed reads
            for (uint32_t i = 0; i < completed; ++i) {
                active_reads.erase(active_keys.front());
                active_keys.pop_front();
            }
            completed = 0;
        }

        // update active_reads with the reads from the current line
        for (uint32_t i = 0; i < curr_read.read_ids.size(); ++i) {
            auto read_it = active_reads.find(curr_read.read_ids[i]);
            const char curr_base = curr_read.bases[i];
            if (read_it == active_reads.end()) { // create a new read
                Read read = { { curr_base }, line_count, curr_read.cell_ids[i], { curr_read.pos } };
                active_reads[curr_read.read_ids[i]] = read;
                active_keys.push_back(curr_read.read_ids[i]);
            } else {
                Read &read = read_it->second;
                // if we have two reads at the same position (happens due to paired-end sequencing)
                if (!read.pos.empty() && read.pos.back() == curr_read.pos) {
                    // different reads at the same position, so we remove the existing read, as
                    // there's a 50% chance of error
                    if (toupper(read.bases.back()) != toupper(curr_base)) {
                        read.bases.pop_back();
                        read.pos.pop_back();
                    }
                    continue;
                }

                // add a new base to an existing read
                assert(read.pos.empty() || read.pos.back() < curr_read.pos);
                read.bases.push_back(curr_base);
                read.pos.push_back(curr_read.pos);
            }
        }

        read_progress += line.size() + 1;
    }
    f.close();

    // in the end, process all the leftover active reads
#pragma omp parallel for num_threads(FLAGS_num_threads)
    for (uint32_t i = 0; i < active_keys.size(); ++i) {
        // compare with all other reads in active_reads
        compare_with_reads(active_reads, active_keys, i, cell_ids, cell_groups, cache, updates_same,
                           updates_diff, log_probs_same, log_probs_diff, combs_xs_xd);
    }

    apply_updates(updates_same, mat_same);
    apply_updates(updates_diff, mat_diff);

    // save mat_same and mat_diff into file
    write_mat(FLAGS_out_dir + "mat_same_" + std::to_string(FLAGS_run_id) + ".csv", mat_same);
    write_mat(FLAGS_out_dir + "mat_diff_" + std::to_string(FLAGS_run_id) + ".csv", mat_diff);
    write_mat(FLAGS_out_dir + "combs_xs_xd_" + std::to_string(FLAGS_run_id) + ".csv", combs_xs_xd);
}

int main(int argc, char *argv[]) {
    gflags::ParseCommandLineFlags(&argc, &argv, true);

    std::vector<uint32_t> cells_ids;
    if (!FLAGS_cells_file.empty()) {
        cells_ids = int_split(read_file(FLAGS_cells_file), ' ');
        // num_cells = len(cells_ids);
    } else {
        cells_ids.resize(FLAGS_num_cells);
        std::iota(cells_ids.begin(), cells_ids.end(), 0);
    }

    std::vector<uint32_t> cell_groups;
    if (!FLAGS_cell_group_file.empty()) {
        cell_groups = int_split(read_file(FLAGS_cells_file), ',');
    } else {
        cell_groups.resize(FLAGS_num_cells);
        std::iota(cell_groups.begin(), cell_groups.end(), 0);
    }

    computeSimilarityMatrix(cells_ids, cell_groups);
}
