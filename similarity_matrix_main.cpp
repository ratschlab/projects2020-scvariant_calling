/*
 * Generate the distance/affinity matrix that approximates the probability that two cells i and j
 * have the same genotype. The input is a pre-processed mpileup, which contains all of the sequenced
 * bases (piled up) for each position as generated by preprocessing.py.
 * Each line in the file has the form:
 * chromosome_id    position    coverage    bases   cells   read_ids
 * For example the line:
 * 22      10719571        2       TAG      0,0,3  read_id1,read_id2,read_id3
 * Means that at position 10719571 of chromosome 22, we read 'T' and 'A' in cell 0 and 'G' in cell 3
 */

#include "util.hpp"

#include <gflags/gflags.h>

#include <fstream>
#include <limits>
#include <numeric>
#include <sstream>
#include <unordered_map>
#include <vector>

#include <cassert>
#include <cmath>
#include <iostream>

DEFINE_double(seq_error_rate, 0.001, "Sequencing errors rate, denoted by theta");
DEFINE_double(mutation_rate,
              0,
              "epsilon, estimated frequency of mutated loci in the pre-processed data set");
// estimate of how many positions are actually homozygous germline, were only included because of
// sequencing (or alignment!) errors
DEFINE_double(
        hzygous_prob,
        0,
        "The probability that a loci is homozygous, (not filtered correctly in the first step");

DEFINE_string(mpileup_file,
              "",
              "Input file containing 'pileup' textual format from an alignment, as written by "
              "preprocessing.py");
DEFINE_uint32(num_cells, 0, "Number of sequenced cells");
DEFINE_string(cells_file,
              "",
              "File with identifiers of cells (numbers between 0 and (num_of_cells - 1); the "
              "matrices will be computed only for these cells; if absent, all cells are used.");
DEFINE_string(cell_group_file,
              "",
              "For each cell, it contains a group to which it belongs. Cells from one group will "
              "be treated as one cell. Useful e.g. when creating data with artificially higher "
              "coverage; if absent, each cell has its own group");

DEFINE_string(out_dir, "./", "Directory where the similarity matrices will be written to");
DEFINE_uint32(run_id,
              0,
              "Identifier of the run (e.g. chromosome number); the resulting files will be called "
              "'mat_same_<run_id>.csv' and 'mat_diff_<id>.csv'");
DEFINE_uint32(max_read_size,
              1000,
              "Maximal considered insert size (for paired-end sequencing). In plain English, this "
              "is the maximal length of a read we consider. Reads that are longer will not be "
              "mapped correctly.");


/** Caches a bunch of combinations and powers used again and again in the computation */
struct Cache {
    const double epsilon = FLAGS_mutation_rate;
    const double h = FLAGS_hzygous_prob;

    // probability that two same letters will be read as different
    const double theta = FLAGS_seq_error_rate;
    const double theta2 = theta * theta;
    const double p_same_diff = 2 * theta * (1 - theta) + 2 * theta2 / 3;
    // probability that two same letters will be read as same
    const double p_same_same = 1 - p_same_diff;
    // probability that two different letters will be read as same
    const double p_diff_same = 2 * (1 - theta) * theta / 3 + 2 * theta2 / 9;
    // probability that two different letters will be read as different
    const double p_diff_diff = 1 - p_diff_same;

    std::vector<double> pow_p_same_same = { 1, p_same_same };
    std::vector<double> pow_p_same_diff = { 1, p_same_diff };
    std::vector<double> pow_p_diff_same = { 1, p_diff_same };
    std::vector<double> pow_p_diff_diff = { 1, p_diff_diff };

    std::vector<double> pow_1_h_epsilon = { 1, 1 - epsilon - h };
    std::vector<double> pow_1_h_epsilon2 = { 1, 1 - epsilon * 0.5 - h };
    std::vector<double> pow_h_epsilon2 = { 1, h + epsilon * 0.5 };
    std::vector<double> pow_h = { 1, h };
    std::vector<double> pow_epsilon = { 1, epsilon };
    std::vector<double> pow_0_5 = { 1, 0.5 };
    std::vector<double> pow_pss_pds = { 1, p_same_same + p_diff_same };
    std::vector<double> pow_psd_pdd = { 1, p_same_diff + p_diff_diff };

    std::vector<std::vector<uint64_t>> comb = { { 1 }, { 1, 1 } };

    void update(uint32_t max) {
        if (max < pow_p_same_same.size()) {
            return; // cache is up to date
        }
        auto extend = [](std::vector<double> &a) { a.push_back(a.back() * a[1]); };
        for (uint32_t p = pow_p_same_same.size(); p <= max; ++p) {
            extend(pow_p_same_same);
            extend(pow_p_same_diff);
            extend(pow_p_diff_same);
            extend(pow_p_diff_diff);
            extend(pow_1_h_epsilon);
            extend(pow_1_h_epsilon2);
            extend(pow_h_epsilon2);
            extend(pow_h);
            extend(pow_epsilon);
            extend(pow_0_5);
            extend(pow_pss_pds);
            extend(pow_psd_pdd);
            std::vector<uint64_t> new_comb(p + 1);
            new_comb[0] = 1;
            new_comb.back() = 1;
            for (uint32_t i = 1; i < comb.back().size(); ++i) {
                new_comb[i] = comb.back()[i - 1] + comb.back()[i];
            }
            comb.push_back(std::move(new_comb));
        }
    }
};

/**
 * Retrieve or compute the probability of having (x_s, x_d) matches/mismatches assuming cells have
 * different genotypes.
 * @param x_s the number of matches
 * @param x_d the number of mismatches
 * @param[in, out] log_probs table containing the cached log probabilities of cells being
 * *different* for x_s and x_d; if the table is empty at the desired location, the value is computed
 * @param[in, out] combs_xs_xd number of times we have seen a combination of x_s and x_d
 * @param[in, out] c caches frequently computed values, such as combinations and powers of h and
 * epsilon
 */
double
log_prob_diff_genotype(uint32_t x_s, uint32_t x_d, Matd &log_probs, Mat32u &combs_xs_xd, Cache &c) {
    combs_xs_xd[x_s][x_d]++;
    if (log_probs[x_s][x_d] != std::numeric_limits<double>::max()) {
        return log_probs[x_s][x_d];
    }
    c.update(x_s + x_d); // TODO: only update combinations to max
    double prob = 0;
    for (uint32_t k = 0; k <= x_s; ++k) {
        for (uint32_t l = 0; l <= x_d; l++) {
            for (uint32_t p = 0; p <= x_s - k; ++p) {
                for (uint32_t q = 0; q <= x_d - l; ++q) {
                    prob += c.comb[x_s][k] * c.comb[x_d][l] * c.comb[x_s - k][p]
                            * c.comb[x_d - l][q] * c.pow_1_h_epsilon[k + l] * 0.5
                            * (c.pow_p_same_same[k] * c.pow_p_same_diff[l]
                               + c.pow_p_diff_same[k] * c.pow_p_diff_diff[l])
                            * c.pow_epsilon[x_s + x_d - k - l - p - q]
                            * c.pow_0_5[x_s + x_d - k - l - p - q] * c.pow_pss_pds[x_s - k - p]
                            * c.pow_psd_pdd[x_d - l - q] * c.pow_h[p + q] * c.pow_p_same_same[p]
                            * c.pow_p_same_diff[q];
                }
            }
        }
    }
    prob *= c.comb[x_s + x_d][x_s];
    log_probs[x_s][x_d] = log(prob);
    return log_probs[x_s][x_d];
}

/**
 * Retrieve or compute the probability of having (x_s, x_d) matches/mismatches assuming cells have
 * the same genotype.
 * @param x_s the number of matches
 * @param x_d the number of mismatches
 * @param[in, out] log_probs table containing the cached log probabilities of cells having the samge
 * genotype given x_s and x_d; if the table is empty at the desired location, the value is computed
 * @param[in, out] combs_xs_xd number of times we have seen a combination of x_s and x_d
 * @param[in, out] c caches frequently computed values, such as combinations and powers of h and
 * epsilon
 */
double
log_prob_same_genotype(uint32_t x_s, uint32_t x_d, Matd &log_probs, Mat32u &combs_xs_xd, Cache &c) {
    combs_xs_xd[x_s][x_d]++;
    if (log_probs[x_s][x_d] != std::numeric_limits<double>::max()) {
        return log_probs[x_s][x_d];
    }
    c.update(x_s + x_d);
    double p = 0;
    for (uint32_t k = 0; k <= x_s; ++k) {
        for (uint32_t l = 0; l <= x_d; l++) {
            p += c.comb[x_s][k] * c.comb[x_d][l] * c.pow_1_h_epsilon2[k + l] * 0.5
                    * (c.pow_p_same_same[k] * c.pow_p_same_diff[l]
                       + c.pow_p_diff_same[k] * c.pow_p_diff_diff[l])
                    * c.pow_h_epsilon2[x_s + x_d - k - l] * c.pow_p_same_same[x_s - k]
                    * c.pow_p_same_diff[x_d - l];
        }
    }
    p *= c.comb[x_s + x_d][x_s];
    log_probs[x_s][x_d] = log(p);
    return log_probs[x_s][x_d];
}

struct Read {
    std::string seq; // the DNA sequence corresponding to this read
    uint32_t line;
    uint32_t cell_id;
    uint32_t pos;
};

struct ParsedLine {
    uint32_t pos; // 1-based position on the chromosome
    std::string bases; // the bases read, one for each coverage
    std::vector<uint32_t> cell_ids; // the cell that produced each read, one for each coverage
    std::vector<std::string> read_ids; // long string identifying each read
};

// parses a line from the preprocessed file and returns the corresponding read
ParsedLine parse_line(const std::string &line) {
    assert(!line.empty());
    std::stringstream stream(line);
    uint32_t unused, position;
    stream >> unused >> position >> unused;
    std::string bases, cell_ids, read_ids;
    stream.get(); // ignore next tab
    std::getline(stream, bases, '\t');
    std::getline(stream, cell_ids, '\t');
    std::getline(stream, read_ids, '\t');
    return { position, bases, int_split(cell_ids, ','), split(read_ids, ',') };
}

void compare_with_reads(const std::unordered_map<std::string, Read> &active_reads,
                        Read read1, // sent by copy as it's changed
                        const std::vector<uint32_t> &cell_ids,
                        const std::vector<uint32_t> &cell_groups,
                        Matd &mat_same,
                        Matd &mat_diff,
                        Matd &log_probs_same,
                        Matd &log_probs_diff,
                        Mat32u &combs_xs_xd,
                        Cache &cache) {
    for (auto it : active_reads) {
        Read read2 = it.second;
        if (read2.cell_id == read1.cell_id) {
            continue; // only compare reads from different cells
        }
        //  read is not from the same cell -> count the number of matches and mismatches in the
        //  overlap (all active reads include the current position in the genome, so they overlap)
        int32_t offset = static_cast<int32_t>(read2.line - read1.line);
        auto it1 = read1.seq.cbegin() + (offset > 0 ? offset : 0);
        auto it2 = read2.seq.cbegin() + (offset > 0 ? 0 : -offset);

        uint32_t x_s = 0;
        uint32_t x_d = 0;
        for (; it1 != read1.seq.end() && it2 != read2.seq.end(); ++it1, ++it2) {
            if (*it1 != '*' && *it2 != '*') {
                toupper(*it1) == toupper(*it2) ? x_s++ : x_d++;
            }
        }
        assert(it2 <= read2.seq.end());

        if (x_s == 0 && x_d == 0) {
            continue; // no overlapping positions, nothing to do
        }

        // update the distance matrices
        uint32_t index1 = cell_groups[cell_ids[read1.cell_id]];
        uint32_t index2 = cell_groups[cell_ids[read2.cell_id]];
        if (index1 != index2) {
            mat_same[index1][index2]
                    += log_prob_same_genotype(x_s, x_d, log_probs_same, combs_xs_xd, cache);
            mat_same[index2][index1] = mat_same[index1][index2];
            mat_diff[index1][index2]
                    += log_prob_diff_genotype(x_s, x_d, log_probs_diff, combs_xs_xd, cache);
            mat_diff[index2][index1] = mat_diff[index1][index2];
        }
    }
}

/**
 * Compute mat_same (the matrix giving probabilities of cells i and j given they are in
 * the same cluster) and mat_diff (prob. of cells i and j given they are in different clusters)
 */
void computeSimilarityMatrix(const std::vector<uint32_t> &cell_ids,
                             const std::vector<uint32_t> &cell_groups) {
    constexpr uint32_t read_len = 100; // maximum read length for computing the

    // distance matrices - the desired result of the computation
    Matd mat_same = newMat(FLAGS_num_cells, FLAGS_num_cells, 0.);
    Matd mat_diff = newMat(FLAGS_num_cells, FLAGS_num_cells, 0.);

    // arrays with values of already computed probabilities, max_double if not yet computed
    Matd log_probs_same = newMat(read_len, read_len, std::numeric_limits<double>::max());
    Matd log_probs_diff = newMat(read_len, read_len, std::numeric_limits<double>::max());

    // count how many times we have seen a given combination of x_s, x_d
    Mat32u combs_xs_xd = newMat(read_len, read_len, 0u);

    // key: read id of an active read
    // value: A Read struct, containing: sequence, line number, cell_id and position in genome
    std::unordered_map<std::string, Read> active_reads;

    Cache cache; // store intermediate values to avoid recomputation

    // traverse the pre-processed mpileup file line by line. Each line in the file has the form:
    // chromosome_id    position    coverage    bases   cells   read_ids
    std::ifstream f(FLAGS_mpileup_file);
    std::string line;
    for (uint32_t line_count = 0; std::getline(f, line); ++line_count) {
        // splits the line by tabs and fills in the relevant fields into parsed_line
        ParsedLine curr_read = parse_line(line);

        // for each active read check if it has a base in the current position
        for (auto it = active_reads.begin(); it != active_reads.end();) {
            Read &read = it->second;
            auto read_id_it
                    = std::find(curr_read.read_ids.begin(), curr_read.read_ids.end(), it->first);
            if (read_id_it != curr_read.read_ids.end()) { // *it has a base at teh current position
                // index of the read in parsed_line.read_ids
                uint32_t read_idx = std::distance(curr_read.read_ids.begin(), read_id_it);
                read.seq += curr_read.bases[read_idx];
                ++it;

            } else if (read.pos >= curr_read.pos - FLAGS_max_read_size) {
                // if we are less than max_read_size from the start of the read,
                // it is possible the read still continues later, only this particular position is
                // unknown (deletion, or low quality, or we are in between the two mates)
                read.seq += '*';
                ++it;

            } else {
                // the read is complete; compute its overlaps with all other active reads, i.e. all
                // reads that have some bases in the last FLAGS_max_read_size positions

                // make a copy before deleting the iterator, which invalidates read
                Read read_copy = read;

                std::string r_id = it->first;
                // remove the read from active_reads
                it = active_reads.erase(it);

                // compare with all other reads in active_reads
                compare_with_reads(active_reads, read_copy, cell_ids, cell_groups, mat_same,
                                   mat_diff, log_probs_same, log_probs_diff, combs_xs_xd, cache);
            }
        }

        // for each read_id in the current line check, if it is in active_reads; if not, add it
        for (uint32_t i = 0; i < curr_read.read_ids.size(); ++i) {
            if (!active_reads.contains(curr_read.read_ids[i])) {
                std::string b(1, curr_read.bases[i]);
                active_reads[curr_read.read_ids[i]]
                        = { b, line_count, curr_read.cell_ids[i], curr_read.pos };
            }
        }
    }
    f.close();

    // in the end, process all the leftover active reads
    for (auto it = active_reads.begin(); it != active_reads.end();) {
        const Read &read = it->second;
        it = active_reads.erase(it); // delete the read from active_reads

        // compare with all other reads in active_reads
        compare_with_reads(active_reads, read, cell_ids, cell_groups, mat_same, mat_diff,
                           log_probs_same, log_probs_diff, combs_xs_xd, cache);
    }

    // save mat_same and mat_diff into file
    write_mat(FLAGS_out_dir + "mat_same_" + std::to_string(FLAGS_run_id) + ".csv", mat_same);
    write_mat(FLAGS_out_dir + "mat_diff_" + std::to_string(FLAGS_run_id) + ".csv", mat_diff);
    write_mat(FLAGS_out_dir + "combs_xs_xd_" + std::to_string(FLAGS_run_id) + ".csv", combs_xs_xd);
}

int main(int argc, char *argv[]) {
    gflags::ParseCommandLineFlags(&argc, &argv, true);

    std::vector<uint32_t> cells_ids;
    if (!FLAGS_cells_file.empty()) {
        cells_ids = int_split(read_file(FLAGS_cells_file), ' ');
        // num_cells = len(cells_ids);
    } else {
        cells_ids.resize(FLAGS_num_cells);
        std::iota(cells_ids.begin(), cells_ids.end(), 0);
    }

    std::vector<uint32_t> cell_groups;
    if (!FLAGS_cell_group_file.empty()) {
        cell_groups = int_split(read_file(FLAGS_cells_file), ',');
    } else {
        cell_groups.resize(FLAGS_num_cells);
        std::iota(cell_groups.begin(), cell_groups.end(), 0);
    }

    computeSimilarityMatrix(cells_ids, cell_groups);
}
